package com.progmasters.moovsmart.service;

import com.progmasters.moovsmart.domain.*;
import com.progmasters.moovsmart.dto.*;
import com.progmasters.moovsmart.repository.AccountRepository;
import com.progmasters.moovsmart.security.UserDetailsServiceImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import javax.persistence.EntityNotFoundException;
import javax.transaction.Transactional;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

@Service
@Transactional
public class AccountService {

    private static final Logger logger = LoggerFactory.getLogger(AccountService.class);
    private Random random = new Random();
    private AccountRepository accountRepository;
    private EmailService emailService;
    private UserDetailsServiceImpl userDetailsServiceImpl;
    private AuthenticationManager authenticationManager;

    @Autowired
    private BCryptPasswordEncoder passwordEncoder;

    @Autowired
    public AccountService(AccountRepository accountRepository, EmailService emailService,
                          UserDetailsServiceImpl userDetailsServiceImpl,
                          AuthenticationManager authenticationManager) {
        this.accountRepository = accountRepository;
        this.emailService = emailService;
        this.userDetailsServiceImpl = userDetailsServiceImpl;
        this.authenticationManager = authenticationManager;
    }

    public List<Account> getAccountListForScheduledKeyPurge() {
        return this.accountRepository.findAll();
    }

    public List<Account> getAdminAccountListForAutoGeneratedMessage() {
        return accountRepository.findAllAdmin(Role.ROLE_ADMIN);
    }

    public AccountProfileDetails getAccountProfileInfo() {
        Account accountByEmail = findAccountByEmail(getUserDetails().getUsername());
        return new AccountProfileDetails(accountByEmail);
    }

    public AccountFormInitData getRegistrationFormInitData() {
        List<RoleDTO> roles = Arrays.stream(Role.values())
                .filter(role -> !role.equals(Role.ROLE_ADMIN))      //NOT admin!
                .map(RoleDTO::new)
                .collect(Collectors.toList());
        return new AccountFormInitData(roles);
    }

    public AccountDetailsNewPasswordFormData getNewPasswordFormData(String newPasswordKey) {
        Account accountByNewPasswordKey = findAccountByNewPasswordKey(newPasswordKey);
        return new AccountDetailsNewPasswordFormData(accountByNewPasswordKey);
    }

    public AccountStatistics getAccountStatistics() {
        AccountStatistics accountStatistics = new AccountStatistics();
        accountStatistics.setNumberOfOwners(
                accountRepository.findActiveAccountNumber(Role.ROLE_OWNER, AccountStatus.ACTIVATED));
        accountStatistics.setNumberOfVisitors(
                accountRepository.findActiveAccountNumber(Role.ROLE_VISITOR, AccountStatus.ACTIVATED));
        accountStatistics.setNumberOfInactive(
                accountRepository.findInactiveAccountNumber(AccountStatus.INACTIVATED));
        accountStatistics.setNumberOfUnconfirmed(
                accountRepository.findInactiveAccountNumber(AccountStatus.UNCONFIRMED));
        return accountStatistics;
    }

    public Long createAccount(AccountCreateCommand accountCreateCommand) {
        Account account = new Account(accountCreateCommand);
        account.setPhoneNumber(accountCreateCommand.getPhoneNumber());
        account.setPassword(passwordEncoder.encode(accountCreateCommand.getPassword()));
        String activationKey = generateKey();
        logger.debug("Generated key for activation: {}", activationKey);
        account.setActivationKey(activationKey);
        emailService.sendActivationMail(accountCreateCommand.getFullName(),
                accountCreateCommand.getEmail(), activationKey);
        Account savedAccount = accountRepository.save(account);
        return savedAccount.getId();
    }

    public void resendActivationEmail(ResendEmailCommand resendEmailCommand) {
        Account accountByEmail = findAccountByEmail(resendEmailCommand.getEmailResend());
        emailService.sendActivationMail(accountByEmail.getFullName(),
                accountByEmail.getEmail(), accountByEmail.getActivationKey());
    }

    public void sendNewPasswordEmail(SendNewPasswordEmailCommand sendNewPasswordEmailCommand) {
        Account accountByEmail = findAccountByEmail(sendNewPasswordEmailCommand.getEmailReset());
        String newPasswordKey = generateKey();
        logger.debug("Generated key for new password: {}", newPasswordKey);
        accountByEmail.setNewPasswordKey(newPasswordKey);
        emailService.sendNewPasswordMail(accountByEmail.getFullName(),
                accountByEmail.getEmail(), accountByEmail.getNewPasswordKey());
    }

    public void activateAccount(String activationKey) {
        Account accountByActivationKey = findAccountByActivationKey(activationKey);
        accountByActivationKey.setAccountStatus(AccountStatus.ACTIVATED);
        accountByActivationKey.setActivationKey("");
    }

    public void saveNewPassword(String newPasswordKey, AccountNewPassword accountNewPassword) {
        Account accountByNewPasswordKey = findAccountByNewPasswordKey(newPasswordKey);
        accountByNewPasswordKey.setPassword(passwordEncoder.encode(accountNewPassword.getPassword()));
        accountByNewPasswordKey.setNewPasswordKey("");
        logger.debug("New password has been saved to account with email: {}", accountByNewPasswordKey.getEmail());
    }

    public Long updateAccount(AccountUpdateCommand accountUpdateCommand) {
        Account accountByEmail = findAccountByEmail(getUserDetails().getUsername());
        accountByEmail.setFullName(accountUpdateCommand.getFullName());
        accountByEmail.setEmail(accountUpdateCommand.getEmail());
        accountByEmail.setPhoneNumber(accountUpdateCommand.getPhoneNumber());
        handleProperties(accountUpdateCommand, accountByEmail);
        accountByEmail.setRole(Role.valueOf(accountUpdateCommand.getRole()));
        if (!accountUpdateCommand.getPassword().equals("")) {
            accountByEmail.setPassword(passwordEncoder.encode(accountUpdateCommand.getPassword()));
            authenticateAfterProfileEdit(accountUpdateCommand.getEmail(), accountUpdateCommand.getPassword());
        }
        return accountByEmail.getId();
    }

    private void handleProperties(AccountUpdateCommand accountUpdateCommand, Account accountByEmail) {
        if (accountUpdateCommand.getRole().equals(Role.ROLE_OWNER.toString())) {
            List<Property> propertyList = accountByEmail.getPropertyList();
            for (Property propertyToActivate : propertyList) {
                if (propertyToActivate.getState().equals(PropertyState.INACTIVE_VISITOR_ACCOUNT)) {
                    propertyToActivate.setState(PropertyState.ACTIVE);
                }
            }
        } else if (accountUpdateCommand.getRole().equals(Role.ROLE_VISITOR.toString())) {
            List<Property> propertyList = accountByEmail.getPropertyList();
            for (Property propertyToInactivate : propertyList) {
                if (propertyToInactivate.getState().equals(PropertyState.ACTIVE)) {
                    propertyToInactivate.setState(PropertyState.INACTIVE_VISITOR_ACCOUNT);
                }
            }
        }
    }

    public boolean deleteOwnAccount() {
        Account accountByEmail = findAccountByEmail(getUserDetails().getUsername());
        if (accountByEmail.getRole().equals(Role.ROLE_ADMIN) || accountByEmail.getRole().equals(Role.ROLE_OWNER)) {
            List<Property> propertyList = accountByEmail.getPropertyList();
            for (Property propertyToInactivate : propertyList) {
                propertyToInactivate.setState(PropertyState.INACTIVE);
            }
        }
        accountByEmail.setAccountStatus(AccountStatus.INACTIVATED);
        logger.debug("Account has been deleted (inactivation) of logged in user, email: {}.",
                getUserDetails().getUsername());
        return true;
    }

    public boolean accountRegistered(Long id) {
        return accountRepository
                .findById(id)
                .isPresent();
    }

    public boolean emailAlreadyRegistered(String email) {
        return accountRepository
                .findByEmail(email)
                .isPresent();
    }

    public boolean updateEmailAlreadyRegistered(String email) {
        boolean isUpdateEmailAlreadyRegistered = false;
        if (emailAlreadyRegistered(email) && !getUserDetails().getUsername().equals(email)) {
            isUpdateEmailAlreadyRegistered = true;
        }
        return isUpdateEmailAlreadyRegistered;
    }

    public boolean checkOriginalPassword(String passwordOriginal) {
        Account accountByEmail = findAccountByEmail(getUserDetails().getUsername());
        return passwordEncoder.matches(passwordOriginal, accountByEmail.getPassword());
    }

    public Account findAccountByEmail(String email) {
        return accountRepository
                .findByEmail(email)
                .orElseThrow(() -> new EntityNotFoundException("Account not found with given email: " + email));
    }

    private Account findAccountByActivationKey(String activationKey) {
        return accountRepository
                .findByActivationKey(activationKey)
                .orElseThrow(() -> new EntityNotFoundException("Account not found with given activation key: " + activationKey));
    }

    private Account findAccountByNewPasswordKey(String newPasswordKey) {
        return accountRepository
                .findByNewPasswordKey(newPasswordKey)
                .orElseThrow(() -> new EntityNotFoundException("Account not found with given new password key: " + newPasswordKey));
    }

    public Account findAccountById(Long accountId) {
        return accountRepository
                .findById(accountId)
                .orElseThrow(() -> new EntityNotFoundException("Account not found with given id: " + accountId));
    }

    private String generateKey() {
        char[] word = new char[16];
        for (int j = 0; j < word.length; j++) {
            word[j] = (char) ('a' + this.random.nextInt(26));
        }
        String activationKey = new String(word);
        logger.debug("Generated random key: {}", activationKey);
        return activationKey;
    }

    private void authenticateAfterProfileEdit(String email, String password) {
        UsernamePasswordAuthenticationToken loginToken = new UsernamePasswordAuthenticationToken(email, password);
        Authentication authenticate = this.authenticationManager.authenticate(loginToken);
        if (authenticate.isAuthenticated()) {
            SecurityContextHolder.getContext().setAuthentication(authenticate);
        }
        logger.debug("User is authenticated after profile edit. Email: {}", email);
    }

    private UserDetails getUserDetails() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return (UserDetails) authentication.getPrincipal();
    }
}
